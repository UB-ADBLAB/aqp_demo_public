/*-------------------------------------------------------------------------
 *
 * aqp_tablesample_swr.c
 *	  support routines for SWR (sampling with replacement) tablesample method
 *
 * This will use abtree if available.
 *
 * IDENTIFICATION
 *	  src/backend/access/tablesample/swr.c
 *-------------------------------------------------------------------------
 */

#include "aqp.h"

#include <access/tsmapi.h>
#include <catalog/pg_type.h>
#include <optimizer/optimizer.h>
#include <utils/builtins.h>

static void aqp_tablesample_swr_sample_scan_get_sample_size(PlannerInfo *root,
										                    RelOptInfo *baserel,
										                    List *paramexprs,
										                    BlockNumber *pages,
										                    double *tuples);
static void aqp_tablesample_swr_begin_sample_scan(SampleScanState *node,
                                                  Datum *params,
                                                  int nparams,
                                                  uint32 seed);
static OffsetNumber aqp_tablesample_swr_next_sample_tuple(SampleScanState *node,
                                                          BlockNumber blockno,
                                                          OffsetNumber maxoffset);

PG_FUNCTION_INFO_V1(aqp_tablesample_swr_tsm_handler);
Datum
aqp_tablesample_swr_tsm_handler(PG_FUNCTION_ARGS)
{
	TsmRoutine *tsm = makeNode(TsmRoutine);

	tsm->parameterTypes = list_make1_oid(INT8OID);
    /* TODO(zy) maybe lock the index to make it repeatable? */
	tsm->repeatable_across_queries = false;
    /* 
     * This is a fake value to force set_tablesample_rel_pathlist() not to
     * generate a materialize node above the tablesample swr().
     *
     * We will generate our own path and remove whatever generated by that
     * anyway, so it will just make our life a bit easier to match a
     * tablesample path.
     */
	tsm->repeatable_across_scans = true;
	
	/* 
	 * This returns a dummy data structure because it should be translated into
	 * a IndexScan instead of a SampleScan.
	 */
	tsm->SampleScanGetSampleSize =
        aqp_tablesample_swr_sample_scan_get_sample_size;
	tsm->InitSampleScan = NULL;
	tsm->BeginSampleScan =
        aqp_tablesample_swr_begin_sample_scan; /* dummy function */
	tsm->NextSampleBlock = NULL;
	tsm->NextSampleTuple =
        aqp_tablesample_swr_next_sample_tuple; /* dummy function */
	tsm->EndSampleScan = NULL;

	return PointerGetDatum(tsm);
}

static void
aqp_tablesample_swr_sample_scan_get_sample_size(PlannerInfo *root,
                                                RelOptInfo *baserel,
                                                List *paramexprs,
                                                BlockNumber *pages,
                                                double *tuples)
{
	Node	*num_rows_node;
	int64	num_rows = 0;

	num_rows_node = (Node *) linitial(paramexprs);
	num_rows_node = estimate_expression_value(root, num_rows_node);

	if (IsA(num_rows_node, Const) && !((Const *) num_rows_node)->constisnull)
	{
		num_rows = DatumGetInt64(((Const *) num_rows_node)->constvalue);
		/* Invalid value, will be set to default. */
		if (num_rows < 0)
			num_rows = 0;
	}

	if (num_rows == 0)
	{
        // XXX(zy) unknown runtime values!
		num_rows = 1000;
	}
	
	/* 
	 * We'll access at least one page for each of the sample, although some of
	 * them might be duplicates. That doesn't matter because they are always
	 * random access to the heap file, and we pay the I/O cost anyway unless
	 * the heap file fits in memory.
	 */
	*pages = (double) num_rows;

	*tuples = (double) num_rows;
}

static void
aqp_tablesample_swr_begin_sample_scan(SampleScanState *node,
                                      Datum *params,
                                      int nparams,
                                      uint32 seed)
{
    elog(ERROR, "tablesample swr() should be rewritten as a "
                "CustomScan(AQPSWRIndexScan) or CustomScan(AQPSWRIndexOnlyScan)");
}

static OffsetNumber
aqp_tablesample_swr_next_sample_tuple(SampleScanState *node,
                                      BlockNumber blockno,
                                      OffsetNumber maxoffset)
{
    elog(ERROR, "tablesample swr() should be rewritten as a "
                "CustomScan(AQPSWRIndexScan) or CustomScan(AQPSWRIndexOnlyScan)");
}

